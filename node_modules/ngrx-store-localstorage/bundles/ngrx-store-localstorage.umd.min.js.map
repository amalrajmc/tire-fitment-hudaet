{"version":3,"sources":["../../src/lib/index.ts"],"names":["INIT_ACTION","detectDate","dateReviver","_key","value","test","Date","dummyReviver","checkIsBrowserEnv","window","validateStateKeys","keys","map","key","attr","Object","TypeError","rehydrateApplicationState","storage","storageKeySerializer","restoreDates","reduce","acc","curr","deserialize","decrypt","reviver","encrypt","console","error","undefined","stateSlice","getItem","isObjectRegex","RegExp","raw","charAt","JSON","parse","assign","_a","syncStateUpdate","state","removeOnUndefined","syncCondition","e","forEach","replacer","space","name","serialize","filter","createStateSlice","existingSlice","memo","prototype","hasOwnProperty","call","element","stringify","setItem","warn","removeItem","defaultMergeReducer","rehydratedState","action","type","deepmerge","arrayMerge","destinationArray","sourceArray","options","config","reducer","checkStorageAvailability","localStorage","mergeReducer","stateKeys","rehydrate","nextState"],"mappings":"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","sourcesContent":["import * as deepmerge from 'deepmerge';\n\nconst INIT_ACTION = '@ngrx/store/init';\nconst UPDATE_ACTION = '@ngrx/store/update-reducers';\nconst detectDate = /(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})/;\n\n// correctly parse dates from local storage\nexport const dateReviver = (_key: string, value: any) => {\n    if (typeof value === 'string' && detectDate.test(value)) {\n        return new Date(value);\n    }\n    return value;\n};\n\nconst dummyReviver = (_key: string, value: any) => value;\n\nconst checkIsBrowserEnv = () => {\n    return typeof window !== 'undefined';\n};\n\nconst validateStateKeys = (keys: Keys) => {\n    return (keys as any[]).map((key) => {\n        let attr = key;\n\n        if (typeof key === 'object') {\n            attr = Object.keys(key)[0];\n        }\n\n        if (typeof attr !== 'string') {\n            throw new TypeError(\n                `localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`\n            );\n        }\n        return key;\n    });\n};\n\nexport const rehydrateApplicationState = (\n    keys: Keys,\n    storage: Storage,\n    storageKeySerializer: (key: string) => string,\n    restoreDates: boolean\n) => {\n    return (keys as any[]).reduce((acc, curr) => {\n        let key = curr;\n        let reviver = restoreDates ? dateReviver : dummyReviver;\n        let deserialize: (arg0: string) => any;\n        let decrypt: (arg0: string) => string;\n\n        if (typeof key === 'object') {\n            key = Object.keys(key)[0];\n            // use the custom reviver function\n            if (typeof curr[key] === 'function') {\n                reviver = curr[key];\n            } else {\n                // use custom reviver function if available\n                if (curr[key].reviver) {\n                    reviver = curr[key].reviver;\n                }\n                // use custom serialize function if available\n                if (curr[key].deserialize) {\n                    deserialize = curr[key].deserialize;\n                }\n            }\n\n            // Ensure that encrypt and decrypt functions are both present\n            if (curr[key].encrypt && curr[key].decrypt) {\n                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {\n                    decrypt = curr[key].decrypt;\n                } else {\n                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);\n                }\n            } else if (curr[key].encrypt || curr[key].decrypt) {\n                // Let know that one of the encryption functions is not provided\n                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);\n            }\n        }\n        if (storage !== undefined) {\n            let stateSlice = storage.getItem(storageKeySerializer(key));\n            if (stateSlice) {\n                // Use provided decrypt function\n                if (decrypt) {\n                    stateSlice = decrypt(stateSlice);\n                }\n\n                const isObjectRegex = new RegExp('{|\\\\[');\n                let raw = stateSlice;\n\n                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {\n                    raw = JSON.parse(stateSlice, reviver);\n                }\n\n                return Object.assign({}, acc, {\n                    [key]: deserialize ? deserialize(raw) : raw,\n                });\n            }\n        }\n        return acc;\n    }, {});\n};\n\n// Recursively traverse all properties of the existing slice as defined by the `filter` argument,\n// and output the new object with extraneous properties removed.\nfunction createStateSlice(existingSlice: any, filter: (string | number | KeyConfiguration | Options)[]) {\n    return filter.reduce(\n        (memo: { [x: string]: any; [x: number]: any }, attr: string | number | KeyConfiguration | Options) => {\n            if (typeof attr === 'string' || typeof attr === 'number') {\n                const value = existingSlice?.[attr];\n                if (value !== undefined) {\n                    memo[attr] = value;\n                }\n            } else {\n                for (const key in attr) {\n                    if (Object.prototype.hasOwnProperty.call(attr, key)) {\n                        const element = attr[key];\n                        memo[key] = createStateSlice(existingSlice[key], element);\n                    }\n                }\n            }\n            return memo;\n        },\n        {}\n    );\n}\n\nexport const syncStateUpdate = (\n    state: any,\n    keys: Keys,\n    storage: Storage,\n    storageKeySerializer: (key: string | number) => string,\n    removeOnUndefined: boolean,\n    syncCondition?: (state: any) => any\n) => {\n    if (syncCondition) {\n        try {\n            if (syncCondition(state) !== true) {\n                return;\n            }\n        } catch (e) {\n            // Treat TypeError as do not sync\n            if (e instanceof TypeError) {\n                return;\n            }\n            throw e;\n        }\n    }\n\n    keys.forEach((key: string | KeyConfiguration | Options | ((key: string, value: any) => any)): void => {\n        let stateSlice = state[key as string];\n        let replacer;\n        let space: string | number;\n        let encrypt;\n\n        if (typeof key === 'object') {\n            let name = Object.keys(key)[0];\n            stateSlice = state[name];\n\n            if (typeof stateSlice !== 'undefined' && key[name]) {\n                // use serialize function if specified.\n                if (key[name].serialize) {\n                    stateSlice = key[name].serialize(stateSlice);\n                } else {\n                    // if serialize function is not specified filter on fields if an array has been provided.\n                    let filter: KeyConfiguration[];\n                    if (key[name].reduce) {\n                        filter = key[name];\n                    } else if (key[name].filter) {\n                        filter = key[name].filter;\n                    }\n                    if (filter) {\n                        stateSlice = createStateSlice(stateSlice, filter);\n                    }\n\n                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()\n                    if (key[name].encrypt && key[name].decrypt) {\n                        if (typeof key[name].encrypt === 'function') {\n                            encrypt = key[name].encrypt;\n                        }\n                    } else if (key[name].encrypt || key[name].decrypt) {\n                        // If one of those is not present, then let know that one is missing\n                        console.error(\n                            `Either encrypt or decrypt function is not present on '${key[name]}' key object.`\n                        );\n                    }\n                }\n\n                /*\n          Replacer and space arguments to pass to JSON.stringify.\n          If these fields don't exist, undefined will be passed.\n        */\n                replacer = key[name].replacer;\n                space = key[name].space;\n            }\n\n            key = name;\n        }\n\n        if (typeof stateSlice !== 'undefined' && storage !== undefined) {\n            try {\n                if (encrypt) {\n                    // ensure that a string message is passed\n                    stateSlice = encrypt(\n                        typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space)\n                    );\n                }\n                storage.setItem(\n                    storageKeySerializer(key as string),\n                    typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space)\n                );\n            } catch (e) {\n                console.warn('Unable to save state to localStorage:', e);\n            }\n        } else if (typeof stateSlice === 'undefined' && removeOnUndefined) {\n            try {\n                storage.removeItem(storageKeySerializer(key as string));\n            } catch (e) {\n                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);\n            }\n        }\n    });\n};\n\n// Default merge strategy is a full deep merge.\nexport const defaultMergeReducer = (state: any, rehydratedState: any, action: any) => {\n    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {\n        const overwriteMerge = (destinationArray: any, sourceArray: any, options: any) => sourceArray;\n        const options: deepmerge.Options = {\n            arrayMerge: overwriteMerge,\n        };\n\n        state = deepmerge(state, rehydratedState, options);\n    }\n\n    return state;\n};\n\nexport const localStorageSync = (config: LocalStorageConfig) => (reducer: any) => {\n    if (\n        (config.storage === undefined && !config.checkStorageAvailability) ||\n        (config.checkStorageAvailability && checkIsBrowserEnv())\n    ) {\n        config.storage = localStorage || window.localStorage;\n    }\n\n    if (config.storageKeySerializer === undefined) {\n        config.storageKeySerializer = (key) => key;\n    }\n\n    if (config.restoreDates === undefined) {\n        config.restoreDates = true;\n    }\n\n    // Use default merge reducer.\n    let mergeReducer = config.mergeReducer;\n\n    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {\n        mergeReducer = defaultMergeReducer;\n    }\n\n    const stateKeys = validateStateKeys(config.keys);\n    const rehydratedState = config.rehydrate\n        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)\n        : undefined;\n\n    return function (state: any, action: any) {\n        let nextState: any;\n\n        // If state arrives undefined, we need to let it through the supplied reducer\n        // in order to get a complete state as defined by user\n        if (action.type === INIT_ACTION && !state) {\n            nextState = reducer(state, action);\n        } else {\n            nextState = { ...state };\n        }\n\n        // Merge the store state with the rehydrated state using\n        // either a user-defined reducer or the default.\n        nextState = mergeReducer(nextState, rehydratedState, action);\n\n        nextState = reducer(nextState, action);\n\n        if (action.type !== INIT_ACTION) {\n            syncStateUpdate(\n                nextState,\n                stateKeys,\n                config.storage,\n                config.storageKeySerializer,\n                config.removeOnUndefined,\n                config.syncCondition\n            );\n        }\n\n        return nextState;\n    };\n};\n\nexport interface LocalStorageConfig {\n    keys: Keys;\n    rehydrate?: boolean;\n    storage?: Storage;\n    removeOnUndefined?: boolean;\n    restoreDates?: boolean;\n    storageKeySerializer?: (key: string) => string;\n    syncCondition?: (state: any) => any;\n    checkStorageAvailability?: boolean;\n    mergeReducer?: (state: any, rehydratedState: any, action: any) => any;\n}\n\ninterface KeyConfiguration {\n    [key: string]: string[] | number[] | KeyConfiguration[] | Options | ((key: string, value: any) => any);\n}\n\ninterface Options {\n    serialize?: (state: any) => any;\n    deserialize?: (state: any) => any;\n    reviver?: (key: string, value: any) => any;\n    replacer?: ((key: string, value: any) => any) | string[];\n    encrypt?: (message: string) => string;\n    decrypt?: (message: string) => string;\n    filter?: string[];\n    space?: string | number;\n}\n\nexport type Keys = (KeyConfiguration | Options| string)[];\n"]}